<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="操作系统与程序训练"><meta name="keywords" content="linux、c语言"><meta name="author" content="liaoxuan"><meta name="copyright" content="liaoxuan"><title>操作系统与程序训练 | lx's blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="toc-number">1.</span> <span class="toc-text">C语言和操作系统的交互</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%B5%81%E3%80%81%E8%BE%93%E5%87%BA%E6%B5%81%E3%80%81%E9%94%99%E8%AF%AF%E6%B5%81"><span class="toc-number">2.</span> <span class="toc-text">Linux标准输入流、输出流、错误流</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">3.</span> <span class="toc-text">Linux流重定向</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E7%AE%A1%E9%81%93"><span class="toc-number">4.</span> <span class="toc-text">Linux管道</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#make%E5%91%BD%E4%BB%A4"><span class="toc-number">5.</span> <span class="toc-text">make命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gcc%E7%BC%96%E8%AF%91%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">5.0.1.</span> <span class="toc-text">gcc编译常用参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GDB%E8%B0%83%E8%AF%95"><span class="toc-number">6.</span> <span class="toc-text">GDB调试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">7.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">8.</span> <span class="toc-text">程序内存分配</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss3.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D450%2C600/sign=99a1e582fb039245a1e0e90bb2a488f4/9a504fc2d5628535bfb2c16e97ef76c6a7ef632a.jpg"></div><div class="author-info__name text-center">liaoxuan</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/liaoxuan6">Follow me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">5</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">3</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://panlianghnu.github.io">楠桐一号</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://zichao-xie.github.io">楠桐二号</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">lx's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/me">About me</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">操作系统与程序训练</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-05</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="C语言和操作系统的交互"><a href="#C语言和操作系统的交互" class="headerlink" title="C语言和操作系统的交互"></a>C语言和操作系统的交互</h1><p>C语言的main函数其实就是和操作系统的交互之一，执行程序前，操作系统将程序的二进制可执行代码加载到内存的代码段，同时会把函数名为main的函数作为程序的入口。</p>
<p>C语言的int main(int argv,char * argc[]) ，参数从终端读参数， argc用于存放命令行参数个数；argv是一个字符指针的数组（不是一个字符型指针），数组的每个元素都是一个字符指针，指向一个字符串；有些情况main函数还有第三个参数envp，也是一个字符指针的数组，这个数组的每一个元素是指向一个环境变量的字符串。</p>
<p>c语言main函数需要有一个int型返回值，return 0是程序正常退出，return 非零是异常退出，这是返回给控制台的，是给操作系统识别的，通过对返回值的判断，操作系统会执行不同的处理。终端中可以通过echo $?命令打印上条命令返回值。</p>
<p><img src="/2021/04/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%AD%E7%BB%83/main%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0.png" alt="main函数参数"></p>
<p><img src="/2021/04/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%AD%E7%BB%83/%E6%89%93%E5%8D%B0main%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0.png" alt="打印main函数参数"></p>
<h1 id="Linux标准输入流、输出流、错误流"><a href="#Linux标准输入流、输出流、错误流" class="headerlink" title="Linux标准输入流、输出流、错误流"></a>Linux标准输入流、输出流、错误流</h1><p>linux中有三种标准输入输出，分别是stdin，stdout，stderr，对应的描述符分别为0，1，2</p>
<ul>
<li>stdin：标准输入，默认从键盘读取信息</li>
<li>stdout：标准输出，默认将结果输入到终端</li>
<li>stderr：标准错误流，默认将输出结果输出至终端</li>
</ul>
<p>在linux shell执行命令时，每个进程都和三个打开的文件相联系，默认情况下为stdin\stdout\stderr这三个文件。</p>
<h1 id="Linux流重定向"><a href="#Linux流重定向" class="headerlink" title="Linux流重定向"></a>Linux流重定向</h1><p>linux在终端可以通过描述符和重定向符改变程序运行的输入来源和输出地点</p>
<p>重定向符：“&lt;”，”&gt;”，“&gt;&gt;”</p>
<p>双箭头不会覆盖文件，会在文件末尾继续写入</p>
<p>单箭头则会覆盖文件</p>
<p>输出重定向：</p>
<p><img src="/2021/04/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%AD%E7%BB%83/helloworld%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="helloworld重定向"></p>
<p><img src="/2021/04/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%AD%E7%BB%83/ls%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="ls重定向"></p>
<p>输入重定向：</p>
<p><img src="/2021/04/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%AD%E7%BB%83/%E8%BE%93%E5%85%A5%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="输入重定向"></p>
<h1 id="Linux管道"><a href="#Linux管道" class="headerlink" title="Linux管道"></a>Linux管道</h1><p>管道是linux由Unix继承过来的进程间通信机制。其思想是在内存中创建一个共享文件，从而使通信双方利用这个共享文件来传递信息，它表现出来的形式将前面每一个进程的输出（stdout)直接作为下一个进程的输入（stdin)，由于这种方式具有单向传递数据的特点，所以这个作为传递消息的共享文件就叫做“管道”。</p>
<p>命令执行顺序控制</p>
<ul>
<li><p>顺序执行多条命令：command1;command2;command3</p>
</li>
<li><p>有条件的执行多条命令：which command1 &amp;&amp; command2 || command3</p>
<p>&amp;&amp;:如果前一条命令执行成功则执行下一条</p>
<p>||：与&amp;&amp;相反，执行不成功时执行下条命令</p>
</li>
</ul>
<p>管道命令</p>
<p>管道命令使用 | 作为界定符号，管道命令与上面说的连续执行命令不一样</p>
<ul>
<li>管道命令仅能处理stdout，对于stderr会予以忽略</li>
<li>管道命令必须接受来自前一个命令的数据成为stdin继续处理才行</li>
</ul>
<p><img src="/2021/04/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%AD%E7%BB%83/linux%E7%AE%A1%E9%81%93.png" alt="linux管道"></p>
<p>打印/etc/passwd文件中以：为分割符的第一个字段和第六个字段</p>
<p>cut命令：从某一行信息中取出部分信息，参数说明：</p>
<ul>
<li>-d  后面接分隔字符，通常与-f一起使用</li>
<li>-f   根据-d将信息分隔成数段，-f后接数字表示取出第几段</li>
<li>-c  以字符为单位取出固定字符区间的信息</li>
</ul>
<h1 id="make命令"><a href="#make命令" class="headerlink" title="make命令"></a>make命令</h1><p>工作原理：当make 命令被执行时，它会扫描当前目录下Makefile或makefile文件找到目标以及其依赖。如果这些依赖自身也是目标，继续为这些依赖扫描Makefile 建立其依赖关系，然后编译它们。一旦主依赖编译之后，然后就编译主目标,假设你对某个源文件进行了修改，你再次执行make 命令，它将只编译与该源文件相关的目标文件，因此，编译完最终的可执行文件节省了大量的时间。</p>
<p>makefile文件里面主要有三种内容：</p>
<ul>
<li><p>变量声明</p>
<p>变量声明就是一种基本的严格字符替换的操作</p>
<p>例如声明：objects=program.o foo.o utils.o，那么在后面出现的所有$(objects)或者${objects}都会被自动替换成上面的那个字符序列</p>
</li>
<li><p>映射</p>
</li>
<li><p>命令：命令和映射通常联合起来组成以下的结构形式</p>
<p>target（目标文件） ： dependencies（依赖文件）（注意冒号两边有空格)</p>
<p>​    system command(编译命令) （命令要以tab键开头，否则会报缺少分隔副错误）</p>
</li>
</ul>
<p><img src="/2021/04/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%AD%E7%BB%83/%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8.png" alt="文件列表"></p>
<p>编写makefile文件编译上述文件</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OBJS = main.o sort.o</span><br><span class="line"></span><br><span class="line">main : <span class="variable">$(OBJS)</span></span><br><span class="line">	gcc  <span class="variable">$(OBJS)</span> -o main  </span><br><span class="line">main.o : main.c  sort.h</span><br><span class="line">	gcc -c main.c -o main.o</span><br><span class="line">sort.o : sort.c sort.h</span><br><span class="line">	gcc -c sort.c -o sort.o</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf *.o main</span><br></pre></td></tr></table></figure>

<p>编译运行结果：</p>
<p><img src="/2021/04/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%AD%E7%BB%83/make%E7%BC%96%E8%AF%91.png" alt="make编译"></p>
<h3 id="gcc编译常用参数"><a href="#gcc编译常用参数" class="headerlink" title="gcc编译常用参数"></a>gcc编译常用参数</h3><ul>
<li>-c 只编译不链接，生成目标文件 “.o”</li>
<li>-S 只编译不汇编，生成汇编代码文件“.s”</li>
<li>-E 只进行预编译，生成“.i”文件</li>
<li>-g 在可执行程序中包含标准调试信息</li>
<li>as  *.s -o  *.o 汇编文件生成目标文件</li>
</ul>
<h1 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h1><p>使用gdb调试时，需要在编译时使用-g参数</p>
<p>常用命令：</p>
<ul>
<li>start：开始调试，停在第一行代码处</li>
<li>l：list 查看源代码，可加行号或者函数名</li>
<li>b：breakpoint，设置断点，可指定文件、行号、函数名</li>
<li>i：info查看信息</li>
<li>d：delete 删除断点</li>
<li>s：step执行一行源程序代码，如果此代码行中有函数调用，则进入该函数</li>
<li>n：执行一行源程序代码，不进入函数</li>
<li>r：run 运行程序，有断点则运行至断点处</li>
<li>c：contine 继续执行程序至下一断点或程序结束</li>
<li>p：print 显示变量值</li>
<li>display：设置想要跟踪的变量</li>
<li>undispaly</li>
<li>set：设定运行时参数值</li>
<li>show：查看运行时参数</li>
<li>watch：设置一个观察点，当变量被读出或者写入时程序被暂停</li>
</ul>
<p>堆栈相关命令</p>
<ul>
<li>backtrace：打印栈帧指针</li>
<li>frame：打印指定栈帧</li>
<li>info reg：查看寄存器使用情况</li>
<li>info stack：查看堆栈使用情况</li>
<li>up/down：跳转到上/下一层函数</li>
</ul>
<h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><p>如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地质。而且这个函数名表示的就是这个地址，我们可以定义一个指针变量来存放这个地质，这个指针变量就叫作函数指针变量。</p>
<p>函数指针的定义方式为：</p>
<p>​    函数返回值类型 (* 指针变量名) (函数参数列表);</p>
<p>“函数返回值类型”表示该指针变量可以指向具有什么返回值类型的函数；“函数参数列表”表示该指针变量可以指向具有什么参数列表的函数。这个参数列表中只需要写函数的参数类型即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Func</span><span class="params">(<span class="keyword">int</span> x)</span></span>;   <span class="comment">/*声明一个函数*/</span></span><br><span class="line"><span class="keyword">int</span> (*p) (<span class="keyword">int</span> x);  <span class="comment">/*定义一个函数指针*/</span></span><br><span class="line">p = Func;          <span class="comment">/*将Func函数的首地址赋给指针变量p*/</span></span><br></pre></td></tr></table></figure>

<p>函数指针的用处：调用函数、做函数的参数</p>
<p>例如回调函数的执行：在调用A函数时，传入一个B函数的函数指针，在A函数运行期间，调用了B函数，这就是一个回调。</p>
<h1 id="程序内存分配"><a href="#程序内存分配" class="headerlink" title="程序内存分配"></a>程序内存分配</h1><p><img src="/2021/04/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%AD%E7%BB%83/%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="程序内存示意图"></p>
<p>一个c/c++编译的程序占用内存分为以下部分：</p>
<ul>
<li>stack（栈）：又编译器自动分配与释放，存放运行时函数内声明的局部变量、函数参数、返回数据、返回地址等。栈内存用于维护程序运行时环境，每调用一个函数会开辟一个新的栈帧。栈底为高地址，栈顶为低地址。</li>
<li>heap（堆）：堆内存由程序动态申请，例如使用c语言中的malloc函数，堆内存空间较大，可以用于申请大段内存空间，使用完之后要释放内存空间，堆由低地址向高地址生长。</li>
<li>全局区：存放全局变量、静态数据、常量。程序结束后由系统释放。全局区分为已初始化全局区data和未初始化全局区bss。</li>
<li>text（代码区）：存放程序二进制代码。</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">liaoxuan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://liaoxuan6.github.io/2021/04/05/操作系统与程序训练/">http://liaoxuan6.github.io/2021/04/05/操作系统与程序训练/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux%E3%80%81c%E8%AF%AD%E8%A8%80/">linux、c语言</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2021/03/26/Ubuntu%E5%AE%89%E8%A3%85/"><span>Ubuntu安装</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2021 By liaoxuan</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>